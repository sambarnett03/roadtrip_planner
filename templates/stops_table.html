<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stops ‚Äî Editable</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 20px; background: #fafafa; }
    .container { max-width: 1100px; margin: 0 auto; padding-bottom: 80px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .stop-card { background: white; border-radius: 8px; padding: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.06); display:flex; gap:12px; align-items:flex-start; position: relative; }
    
    .left { width: 72px; text-align:center; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; gap: 12px; }
    .meta { font-size: 0.9rem; color: #888; font-weight: bold; }
    
    .drag-handle { cursor: grab; user-select: none; padding: 8px 10px; border-radius: 8px; background:#f3f4f6; color: #555; font-size: 1.2rem; line-height: 1; }
    .drag-handle:active { cursor: grabbing; background: #e5e7eb; }

    /* Delete Button Styles */
    .delete-btn {
      background: none; border: none; cursor: pointer; color: #dc3545; 
      font-size: 1.2rem; opacity: 0.6; transition: opacity 0.2s, color 0.2s;
      padding: 4px;
    }
    .delete-btn:hover { opacity: 1; color: #b02a37; }

    .fields { flex: 1; display:flex; flex-direction:column; gap:8px; }
    .field-row { display:flex; gap:8px; align-items:flex-start; }
    .field-key { width:160px; font-weight:600; color:#333; margin-top: 8px; font-size: 0.95rem; }
    .field-value { flex: 1; }
    
    .field-value input[type="text"], 
    .field-value input[type="number"], 
    .field-value textarea { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #e6e6e6; font-family: inherit; font-size: 0.95rem; box-sizing: border-box; }
    .field-value textarea { min-height:48px; resize:vertical; }
    .field-value input[type="checkbox"] { transform:scale(1.3); margin-top: 10px; cursor: pointer; }
    .field-value input[readonly] { background-color: #f9fafb; color: #666; border-color: #eee; cursor: not-allowed; }

    /* --- COLOUR SELECTOR STYLES --- */
    .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr); 
      gap: 10px;
      max-width: 400px;
    }
    .color-option {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.9rem;
      color: #333;
    }
    .color-option:hover { background-color: #f0f0f0; }
    .color-option input { margin-right: 8px; cursor: pointer; }
    .swatch {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      margin-right: 8px;
      border: 1px solid rgba(0,0,0,0.1);
    }

    /* --- PILL BUTTONS (For Type Selection) --- */
    .pill-group { display: flex; gap: 10px; }
    .pill-option {
      display: inline-flex; align-items: center;
      border: 1px solid #ddd; padding: 6px 12px; border-radius: 20px;
      cursor: pointer; background: white; font-size: 0.9rem; color: #444;
      transition: all 0.2s;
    }
    .pill-option:hover { background: #f9f9f9; border-color: #bbb; }
    
    /* When the radio inside is checked, style the label */
    .pill-option:has(input:checked) {
      background-color: #e3f2fd;
      border-color: #2196f3;
      color: #0d47a1;
      font-weight: 600;
    }
    .pill-option input { margin-right: 6px; cursor: pointer; }
    
    /* Utility to hide rows */
    .hidden-row { display: none !important; }

    /* ---------------------------------- */

    #status { margin-top: 14px; color:#333; font-weight: 500; height: 1.5em; }
    #button-container { position: fixed; bottom: 5vh; right: 5vw; display: flex; flex-direction: column; align-items: flex-end; gap: 1vh; z-index: 9999; }
    .action-button { background-color: white; padding: 10px 15px; border-radius: 8px; font-weight: bold; color: #007BFF; text-decoration: none; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); transition: background-color 0.2s ease; }
    .action-button:hover { background-color: #f0f0f0; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Stops ‚Äî Editable</h1>
    <p style="color:#666; margin-bottom: 20px;">Edit details below. Drag ‚ò∞ to reorder. Use üóë to delete.</p>
    
    <div id="status"></div>

    <div id="stops-grid" class="grid" aria-live="polite">
        <div style="color:#888; font-style:italic;">Loading stops...</div>
    </div>
  </div>

  <div id="button-container">
    {% if owner_id %}
      <a href="{{ url_for('open_map_shared', owner_id=owner_id, map_id=map_id) }}" class="action-button">‚Üê Back to Map</a>
    {% else %}
      <a href="{{ url_for('open_map', map_id=map_id) }}" class="action-button">‚Üê Back to Map</a>
    {% endif %}
  </div>

  <script>
    // Server-injected variables
    const MAP_ID = {{ map_id | tojson }};
    const OWNER_ID = {{ owner_id | tojson }};

    let VISIBLE_KEYS = [
      { key: "name", label: "Place Name", type: "text", readonly: true },
      { key: "nickname", label: "Nickname", type: "text" },
      { key: "desc", label: "Description", type: "text" },
      { key: "colour", label: "Colour", type: "text" },
      { key: "drive", label: "Include in Drive?", type: "bool" }, 
      { key: "place_type", label: "Type of Stop", type: "text" }
    ];

    // Colour Options
    const COLOUR_OPTIONS = [
        { val: "#00008B", name: "Blue" },
        { val: "#008B8B", name: "Cyan" },
        { val: "#DC143C", name: "Red" },
        { val: "#006400", name: "Green" },
        { val: "#8B008B", name: "Purple" },
        { val: "#000000", name: "Black" }
    ];

    // Place Type Options (UPDATED VALUES)
    const TYPE_OPTIONS = [
        { val: "sleep", label: "Overnight Stay" },
        { val: "poi", label: "Point of Interest" }
    ];

    const ownerParam = OWNER_ID || '';
    function stopsUrl(mapId) {
      return '/api/stops?map_id=' + encodeURIComponent(mapId) + (ownerParam ? ('&owner_id=' + encodeURIComponent(ownerParam)) : '');
    }
    function withOwner(obj) {
      const copy = Object.assign({}, obj || {});
      if (ownerParam) copy.owner_id = ownerParam;
      return copy;
    }
    function escapeHtml(s) {
      if (s === undefined || s === null) return '';
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }
    function debounce(fn, wait=500) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    // UI Refs
    const grid = document.getElementById('stops-grid');
    const statusEl = document.getElementById('status');
    
    function setStatus(msg, isError=false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#d32f2f' : '#2e7d32';
      if (!msg) statusEl.innerHTML = '&nbsp;';
    }

    // 1. Load Data
    async function loadStops() {
      setStatus('Loading...');
      try {
        const resp = await fetch(stopsUrl(MAP_ID), { credentials: 'same-origin' });
        if (!resp.ok) throw new Error(`Server returned ${resp.status}`);
        const data = await resp.json();
        
        if (data.map_meta && Array.isArray(data.map_meta.visible_fields) && data.map_meta.visible_fields.length) {
          VISIBLE_KEYS = data.map_meta.visible_fields;
        }
        
        renderStops(data.stops || []);
        setStatus('');
      } catch (err) {
        console.error(err);
        setStatus('Error loading stops: ' + err.message, true);
      }
    }

    // 2. Render Grid
    function renderStops(stops) {
      grid.innerHTML = '';
      if (stops.length === 0) {
        grid.innerHTML = '<div style="padding:20px; color:#666;">No stops found on this map.</div>';
        return;
      }

      stops.forEach((stop, idx) => {
        const docId = stop._doc_id || String(idx);
        const card = document.createElement('div');
        card.className = 'stop-card';
        card.dataset.docId = docId;

        // --- LEFT COLUMN (ID, Drag, Delete) ---
        const left = document.createElement('div');
        left.className = 'left';
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta';
        metaDiv.textContent = `#${idx+1}`;
        left.appendChild(metaDiv);
        
        const dragDiv = document.createElement('div');
        dragDiv.className = 'drag-handle';
        dragDiv.innerHTML = '‚ò∞';
        dragDiv.title = "Drag to reorder";
        left.appendChild(dragDiv);

        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn';
        delBtn.innerHTML = 'üóë'; 
        delBtn.title = "Delete this stop";
        delBtn.onclick = () => deleteStop(docId, card);
        left.appendChild(delBtn);

        card.appendChild(left);

        // --- FIELDS COLUMN ---
        const fields = document.createElement('div');
        fields.className = 'fields';

        VISIBLE_KEYS.forEach(conf => {
          const key = conf.key;
          const label = conf.label || key;
          const type = conf.type || 'text';
          const isReadonly = !!conf.readonly;

          let rawVal = stop.hasOwnProperty(key) ? stop[key] : '';
          
          const row = document.createElement('div');
          row.className = 'field-row';
          row.dataset.rowKey = key; // Tag the row so we can hide it later
          
          let inputHtml = '';
          const commonAttrs = `data-field="${escapeHtml(key)}" ${isReadonly ? 'readonly' : ''}`;

          // --- LOGIC FOR DIFFERENT FIELD TYPES ---
          
          // 1. COLOUR (Radio Grid)
          if (key === 'colour') {
              const groupName = `colour_${docId}`; 
              let gridHtml = '<div class="grid-container">';
              COLOUR_OPTIONS.forEach(opt => {
                  const isChecked = (rawVal === opt.val) ? 'checked' : '';
                  gridHtml += `
                    <label class="color-option">
                      <input type="radio" name="${groupName}" value="${opt.val}" ${isChecked} ${commonAttrs} />
                      <span class="swatch" style="background: ${opt.val};"></span> ${opt.name}
                    </label>
                  `;
              });
              gridHtml += '</div>';
              inputHtml = `<div class="field-value">${gridHtml}</div>`;
          }
          // 2. PLACE TYPE (Special Radio Buttons)
          else if (key === 'place_type') {
              const groupName = `ptype_${docId}`;
              let pillHtml = '<div class="pill-group">';
              
              TYPE_OPTIONS.forEach(opt => {
                  const isChecked = (rawVal === opt.val) ? 'checked' : '';
                  pillHtml += `
                    <label class="pill-option">
                        <input type="radio" name="${groupName}" value="${opt.val}" ${isChecked} ${commonAttrs} />
                        ${opt.label}
                    </label>
                  `;
              });
              pillHtml += '</div>';
              inputHtml = `<div class="field-value">${pillHtml}</div>`;
          }
          // 3. BOOLEAN (Checkbox - triggers visibility)
          else if (type === 'bool') {
            const checked = rawVal ? 'checked' : '';
            // Note: We add an extra class 'toggle-trigger' to identify this specific checkbox
            inputHtml = `<div class="field-value"><input type="checkbox" class="toggle-trigger" ${commonAttrs} ${checked} ${isReadonly ? 'disabled' : ''}></div>`;
          } 
          // 4. NUMBER
          else if (type === 'number') {
            const valStr = (rawVal === null || rawVal === undefined) ? '' : String(rawVal);
            inputHtml = `<div class="field-value"><input type="number" value="${escapeHtml(valStr)}" ${commonAttrs}></div>`;
          } 
          // 5. TEXT
          else {
            const valStr = (rawVal === null || rawVal === undefined) ? '' : String(rawVal);
            if (valStr.length > 60 || valStr.includes('\n') || key === 'desc') {
                inputHtml = `<div class="field-value"><textarea rows="2" ${commonAttrs}>${escapeHtml(valStr)}</textarea></div>`;
            } else {
                inputHtml = `<div class="field-value"><input type="text" value="${escapeHtml(valStr)}" ${commonAttrs}></div>`;
            }
          }

          row.innerHTML = `<div class="field-key">${escapeHtml(label)}</div>` + inputHtml;
          fields.appendChild(row);
        });

        card.appendChild(fields);
        grid.appendChild(card);

        // Initialize visibility
        updateVisibility(card);
      });

      hookupInlineEditing();
      initReorderSortable();
    }

    // Helper: Logic to show/hide the Type row based on Drive checkbox
    function updateVisibility(card) {
        const driveInput = card.querySelector('input[type="checkbox"][data-field="drive"]');
        const typeRow = card.querySelector('.field-row[data-row-key="place_type"]');

        if (driveInput && typeRow) {
            if (driveInput.checked) {
                // If "Include in Drive" is YES -> Hide Type selection
                typeRow.classList.add('hidden-row');
            } else {
                // If "Include in Drive" is NO -> Show Type selection
                typeRow.classList.remove('hidden-row');
            }
        }
    }

    // 3. Update Visual IDs
    function updateVisualIndices() {
        const cards = Array.from(grid.querySelectorAll('.stop-card'));
        cards.forEach((c, i) => {
            const meta = c.querySelector('.meta');
            if (meta) meta.textContent = `#${i+1}`;
        });
    }

    // 4. Delete Function
    async function deleteStop(docId, cardElement) {
        if (!confirm("Are you sure you want to delete this stop?")) return;
        setStatus('Deleting...');
        cardElement.style.opacity = '0.5';

        try {
            const payload = withOwner({ map_id: MAP_ID, doc_id: docId });
            const resp = await fetch('/api/stops/delete', {
                method: 'POST',
                credentials: 'same-origin',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!resp.ok) throw new Error(await resp.text());
            cardElement.remove();
            updateVisualIndices();
            setStatus('Stop deleted.', false);
            setTimeout(() => setStatus(''), 2000);
        } catch (err) {
            cardElement.style.opacity = '1';
            setStatus('Delete failed: ' + err.message, true);
        }
    }

    // 5. Edit Listeners
    function hookupInlineEditing() {
      // Inputs & Textareas
      grid.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(el => {
        if (el.readOnly) return;
        const docId = el.closest('.stop-card').dataset.docId;
        const saveFn = debounce(async (val) => { await patchField(docId, el.dataset.field, val); }, 600); 
        el.addEventListener('input', (e) => saveFn(e.target.value));
      });

      // Checkboxes (Boolean)
      grid.querySelectorAll('input[type="checkbox"]').forEach(chk => {
        if (chk.disabled) return;
        const docId = chk.closest('.stop-card').dataset.docId;
        chk.addEventListener('change', async (e) => {
          if (chk.dataset.field === 'drive') {
              updateVisibility(chk.closest('.stop-card'));
          }
          await patchField(docId, chk.dataset.field, e.target.checked);
        });
      });

      // Radio Buttons (Colour & Place Type)
      grid.querySelectorAll('input[type="radio"]').forEach(radio => {
        if (radio.disabled) return;
        const docId = radio.closest('.stop-card').dataset.docId;
        radio.addEventListener('change', async (e) => {
             if (e.target.checked) {
                 await patchField(docId, radio.dataset.field, e.target.value);
             }
        });
      });
    }

    async function patchField(docId, field, value) {
      if (!docId || !field) return;
      setStatus(`Saving ${field}...`);
      try {
        const payload = withOwner({ map_id: MAP_ID, doc_id: docId, field: field, value: value });
        const resp = await fetch('/api/stops/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error(await resp.text());
        setStatus('Saved.', false);
        setTimeout(() => { if(statusEl.textContent === 'Saved.') setStatus(''); }, 2000);
      } catch (err) {
        setStatus('Failed to save: ' + err.message, true);
      }
    }

    // 6. Reordering
    function initReorderSortable() {
      if (grid.dataset.sortableInitialized) return;
      grid.dataset.sortableInitialized = '1';
      new Sortable(grid, {
        handle: '.drag-handle',
        animation: 150,
        ghostClass: 'dragging-ghost',
        onStart: e => e.item.style.opacity = '0.5',
        onEnd: async e => {
          e.item.style.opacity = '';
          updateVisualIndices(); 
          const order = Array.from(grid.querySelectorAll('.stop-card')).map(c => c.dataset.docId);
          await saveOrder(order);
        }
      });
    }

    async function saveOrder(order) {
      setStatus('Reordering...');
      try {
        const payload = withOwner({ map_id: MAP_ID, order: order });
        const resp = await fetch('/api/stops/reorder', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error(await resp.text());
        setStatus(`New order saved.`);
        setTimeout(() => setStatus(''), 2000);
      } catch (err) {
        setStatus('Reorder failed: ' + err.message, true);
      }
    }

    loadStops();
  </script>
</body>
</html>